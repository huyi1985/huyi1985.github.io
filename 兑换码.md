# 兑换码

> CRC与数据完整性
> 
尽管在错误检测中非常有用，CRC并不能可靠地校验数据完整性（即数据没有发生任何变化），这是因为CRC多项式是线性结构，可以非常容易地故意改变量据而维持CRC不变，参见CRC and how to Reverse it中的证明。我们可以用Message authentication code校验数据完整性。

作者：宣明庆
链接：https://www.zhihu.com/question/29865340/answer/45894223
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

原理基本上是加密解密过程，将一个32位的二进制int来表示4亿兑换码，然后扩充到合适长度用加密算法加密，Base24编码结果。总体上和序列号的方案差不多。再配合网络验证应该可以满足需求中的，高效、防爆刷、防重复兑换。 --------- 在说明原理之前先说明下Base24编码。 Base24编码主要应用在序列号生成上，其实基本的算法思想和Base64都是一样的，只是编码的模式有点变化。 Base64所对应的编码表是 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/= 共计64位。 那针对这个问题我们选定的Base24所对应的编码表是 ABCDEFGHJKLMNPQRSTUVWXYZ 共计24位。去除了影响识别的I和O
Base24的转换方式主要是通过除法的方式来进行 举例说明：假设数值0那么对应A，1对应B 那么24对应BA，25对应的是BB 那么1位字母所能表示的数值上限为24^1-1=23 2位字母能表示的数值上限即为24^2-1=575 13位数值表示的上限即为24^13-1 ，约等于log2(24^13)=59.6bits，也就是说，至少完美表示59位二进制编码内容 而我们需要编码的激活码上限为4亿 约等于log2(4亿)=28.6bits 接近29位，使用int存储占32bits,远小于59bits，因此可以被13位Base24编码。
在此基础上我们规划下bit的定义 [0{5}-0{48}-{6}] |6 Bits标记位|48 Bits数据位|5 Bits校验位| 标记位我们可以写入用于表示兑换物、失效时间等一些离线简单验证的信息 数据位则是这个激活码的基础部分 校验位就是前54Bits校验，可以是简单的hash然后再对32(2^5)求余的余数
那么接下来的问题就是，有什么方便有效的加密解密方式能将我们的32bit存储的激活码编号转换成位48位的数据呢？ —————————— 先把过程补完，原理以后再说 加密算法这里选择的是RC4，当然也可以选择其他加密算法。RC4是一个是应用最广泛的流加密算法，应用在安全套接字层（SSL）（用来保护网络上传输的数据）和WEP（无线网络数据保护）上，最大亮点就在于是算法的简单性和运行速度，在这里用于生成密文速度会非常快。
通过将激活码数字原始的32bits编码+6bits标记位内容+填充0扩充到48bits，随机生成一个密钥，再通过RC4加密，即可得到48bits的密文。因此之前构造的数据结构中的数据位的内容填入该密文，计算出校验位后即生成了59bits的兑换码，再通过Base24编码就可以转换为13位长度的兑换码。
如果需要解密，客户端先验证校验位是否正确，正确请求服务器，服务器取出数据位，解密得出激活码编号和兑换物内容，校验查询使用激活码目录查看数据库是否已经写入，如果已经写入，认为该激活码已经被使用，如果没有使用将该激活码编号存入数据库，因为激活码编号是一个纯32位无重复的整数，因此可以以激活码编号为主键建立数据库，查询效率将会非常高效。
编辑于 2015-04-26


作者：宣明庆
链接：https://www.zhihu.com/question/29865340/answer/45894223
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

原理基本上是加密解密过程，将一个32位的二进制int来表示4亿兑换码，然后扩充到合适长度用加密算法加密，Base24编码结果。总体上和序列号的方案差不多。再配合网络验证应该可以满足需求中的，高效、防爆刷、防重复兑换。 --------- 在说明原理之前先说明下Base24编码。 Base24编码主要应用在序列号生成上，其实基本的算法思想和Base64都是一样的，只是编码的模式有点变化。 Base64所对应的编码表是 ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/= 共计64位。 那针对这个问题我们选定的Base24所对应的编码表是 ABCDEFGHJKLMNPQRSTUVWXYZ 共计24位。去除了影响识别的I和O
Base24的转换方式主要是通过除法的方式来进行 举例说明：假设数值0那么对应A，1对应B 那么24对应BA，25对应的是BB 那么1位字母所能表示的数值上限为24^1-1=23 2位字母能表示的数值上限即为24^2-1=575 13位数值表示的上限即为24^13-1 ，约等于log2(24^13)=59.6bits，也就是说，至少完美表示59位二进制编码内容 而我们需要编码的激活码上限为4亿 约等于log2(4亿)=28.6bits 接近29位，使用int存储占32bits,远小于59bits，因此可以被13位Base24编码。
在此基础上我们规划下bit的定义 [0{5}-0{48}-{6}] |6 Bits标记位|48 Bits数据位|5 Bits校验位| 标记位我们可以写入用于表示兑换物、失效时间等一些离线简单验证的信息 数据位则是这个激活码的基础部分 校验位就是前54Bits校验，可以是简单的hash然后再对32(2^5)求余的余数
那么接下来的问题就是，有什么方便有效的加密解密方式能将我们的32bit存储的激活码编号转换成位48位的数据呢？ —————————— 先把过程补完，原理以后再说 加密算法这里选择的是RC4，当然也可以选择其他加密算法。RC4是一个是应用最广泛的流加密算法，应用在安全套接字层（SSL）（用来保护网络上传输的数据）和WEP（无线网络数据保护）上，最大亮点就在于是算法的简单性和运行速度，在这里用于生成密文速度会非常快。
通过将激活码数字原始的32bits编码+6bits标记位内容+填充0扩充到48bits，随机生成一个密钥，再通过RC4加密，即可得到48bits的密文。因此之前构造的数据结构中的数据位的内容填入该密文，计算出校验位后即生成了59bits的兑换码，再通过Base24编码就可以转换为13位长度的兑换码。
如果需要解密，客户端先验证校验位是否正确，正确请求服务器，服务器取出数据位，解密得出激活码编号和兑换物内容，校验查询使用激活码目录查看数据库是否已经写入，如果已经写入，认为该激活码已经被使用，如果没有使用将该激活码编号存入数据库，因为激活码编号是一个纯32位无重复的整数，因此可以以激活码编号为主键建立数据库，查询效率将会非常高效。
编辑于 2015-04-26

